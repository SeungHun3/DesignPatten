==========================================================


중괄호 생성자


===========================================================
== 생성자 호출여부 ==

class A {
 public:
  A() { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
  A a();  // 호출 x ==> 함수의 정의로 해석
  A b{};  // 호출 o

return 0;
}

===========================================================
== 암시적 변환여부 ==

class A {
 public:
  A(int x) { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
  A a(3.5);  // Narrow-conversion 가능
  A b{3.5};  // Narrow-conversion 불가

return 0;
}


===========================================================

initializer_list 는 우리가 {} 를 이용해서 생성자를 호출할 때, 
클래스의 생성자들 중에 initializer_list 를 인자로 받는 생성자가 있다면 전달됩니다.
() 를 사용해서 생성자를 호출한다면 intializer_list 가 생성되지 않습니다.

== initializer_list == 
initializer_list 를 이용하면 컨테이너들을 간단하게 정의할 수 있습니다.

class A {
 public:
  A(std::initializer_list<int> mylist) {
	for (auto itr = mylist.begin(); itr != mylist.end(); ++itr) {
	  std::cout << *itr << std::endl;
	}
  }
};

int main() {

A a = {1, 2, 3, 4, 5};

return 0;
}


==========================================================


explicit


===========================================================

#include <iostream>

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;

 public:
  // capacity 만큼 미리 할당함. (explicit 키워드에 주목)
  explicit MyString(int capacity);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length() const;
  int capacity() const;
};

// .. (생략) ..

void DoSomethingWithString(MyString s) {
  // Do something...
}

int main() {
  DoSomethingWithString(3);  // ????
}

DoSomethingWithString(3) 부분에서 컴파일 오류가 발생 => int capacity 를 인자로 받는 생성자가

// capacity 만큼 미리 할당함. (explicit 키워드에 주목)
explicit MyString(int capacity);

위의 explicit 으로 되어 있기 때문. explicit 은 implicit 의 반대말로, 명시적 이라는 뜻을 가지고 있습니다.

explicit이 없다면
DoSomethingWithString(3);은 
MyString('3')이 아닌
DoSomethingWithString(MyString(3))으로 변환되어 의도하지 않은 암시적 변환이 발생하게 됨

==> 명확한 의도를 나타내는 키워드로 
MyString s(5);   // 허용
MyString s = 5;  // 컴파일 오류! 
와 같이 생성자에만 사용할 수 있도록 하기도 함